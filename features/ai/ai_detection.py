# features/ai/ai_detection.py
"""
/ai_detect
General AI Detection (Turnitin-style, non-IELTS)

Flow:
1) User sends /ai_detect
2) Bot asks for TEXT
3) User sends text
4) Bot analyzes AI probability
5) Bot shows result + next actions
"""

import logging
import os
import json
import re

from telegram import (
    Update,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
)
from telegram.ext import (
    CallbackContext,
    CommandHandler,
    ConversationHandler,
    MessageHandler,
    Filters,
)
from telegram.ext import DispatcherHandlerStop

import openai
from database import (
    get_checker_mode,
    set_checker_mode,
    clear_checker_mode,
)

logger = logging.getLogger(__name__)
openai.api_key = os.getenv("OPENAI_API_KEY")

# ---------- States ----------
WAITING_FOR_TEXT = 0

# ---------- Config ----------
MIN_WORDS = 120

# ---------- SYSTEM PROMPT ----------
SYSTEM_PROMPT = """
You are an AI text analysis system.

Your task is to estimate the likelihood that a text was generated by an AI language model.

IMPORTANT INTERPRETATION RULES:
- AI likelihood is a PROBABILITY, not a factual claim.
- It does NOT mean how much of the text was written by AI.
- It reflects how closely the text's patterns resemble typical AI-generated language.

CRITICAL DISTINCTIONS (VERY IMPORTANT):
- Poor grammar, awkward phrasing, spelling mistakes, and inconsistent errors are STRONG indicators of HUMAN writing, especially by non-native speakers.
- AI-generated text usually has:
  ‚Ä¢ consistent grammar
  ‚Ä¢ smooth sentence flow
  ‚Ä¢ balanced vocabulary
  ‚Ä¢ minimal random errors
- Do NOT treat low language proficiency, learner-style English, or exam-template writing as AI signals by default.

WHEN LOWERING AI LIKELIHOOD:
- Frequent and inconsistent grammatical mistakes
- Literal translations from another language
- Uneven sentence quality
- Redundant or messy rewriting
- Emotional or culturally specific additions that feel spontaneous

WHEN RAISING AI LIKELIHOOD:
- Overly smooth, polished, and predictable language
- Uniform sentence length and structure
- Formulaic transitions used perfectly throughout
- High coherence with low variation
- Repetition that appears optimized, not accidental

OUTPUT REQUIREMENTS:
- Never accuse the user.
- Never say "written by AI".
- Never mention specific AI models.
- Be neutral and cautious.
- If signals are mixed, prefer MEDIUM or LOW confidence.

You must return STRICT JSON ONLY in the following format:

{
  "ai_probability": "<integer 0‚Äì100>",
  "confidence": "<Low | Medium | High>",
  "explanation": "<2‚Äì3 short neutral sentences explaining the probability>",
  "ai_segments": "<brief description of where AI-like patterns may appear, or 'No specific segments strongly stand out'>"
}

RULES:
- No markdown.
- No extra text.
- No explanations outside JSON.
- If the text appears clearly human-written but structured, keep AI probability BELOW 50.
"""

# ---------- Helpers ----------

def _ai_color_tone(ai_probability: int) -> str:
    """
    Maps AI likelihood to color emoji.
    """
    if ai_probability < 30:
        return "üü¢"
    elif ai_probability < 50:
        return "üü§"
    elif ai_probability < 70:
        return "üü†"
    else:
        return "üî¥"

def _safe_int(value, default=0):
    try:
        value = str(value).replace("%", "").strip()
        num = int(float(value))
        return max(0, min(100, num))
    except Exception:
        return default


def _word_count(text: str) -> int:
    return len(re.findall(r"\b\w+\b", text))


def _next_actions_keyboard():
    return InlineKeyboardMarkup(
        [
            [
                InlineKeyboardButton("‚ú® Humanize text", callback_data="ai_humanize"),
                InlineKeyboardButton("üîç Check plagiarism", callback_data="ai_plagiarism"),
            ],
            [
                InlineKeyboardButton("üîÅ Re-check AI score", callback_data="ai_recheck"),
                InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="ai_back"),
            ],
        ]
    )


def _format_result(data: dict) -> str:
    raw_prob = data.get("ai_probability", 0)
    ai_prob = _safe_int(raw_prob)
    color = _ai_color_tone(ai_prob)
    confidence = data.get("confidence", "‚Äî")
    explanation = data.get("explanation", "‚Äî")
    segments = data.get("ai_segments", "‚Äî")

    return (
        f"<b>ü§ñ AI Detection Result</b>\n\n"
        f"<b>AI likelihood:</b> {ai_prob}% {color}\n"
        f"<b>Confidence:</b> {confidence}\n\n"
        f"<b>üß† Explanation</b>\n"
        f"{explanation}\n\n"
        f"<b>üîé AI-like patterns</b>\n"
        f"{segments}"
    )


# ---------- Handlers ----------

def start_ai_detect(update: Update, context: CallbackContext):
    user = update.effective_user
    if not user:
        return ConversationHandler.END

    # Prevent mode collision
    if get_checker_mode(user.id):
        update.message.reply_text(
            "‚ö†Ô∏è Avvalgi tekshiruv yakunlanmagan.\n"
            "Iltimos, uni tugating yoki /cancel bosing."
        )
        raise DispatcherHandlerStop

    set_checker_mode(user.id, "ai_detect")
    context.user_data.clear()

    update.message.reply_text(
        "üß† <b>AI Detection</b>\n\n"
        "Iltimos, tekshirmoqchi bo‚Äòlgan matnni yuboring.\n"
        f"(Kamida {MIN_WORDS} so‚Äòz)",
        parse_mode="HTML"
    )

    return WAITING_FOR_TEXT


def collect_text(update: Update, context: CallbackContext):
    user = update.effective_user
    if not user or get_checker_mode(user.id) != "ai_detect":
        return WAITING_FOR_TEXT

    text = update.message.text or ""
    words = _word_count(text)

    if words < MIN_WORDS:
        update.message.reply_text(
            f"‚ö†Ô∏è Matn juda qisqa.\n"
            f"Kamida {MIN_WORDS} so‚Äòz bo‚Äòlishi kerak.\n"
            f"Hozirgi: {words} so‚Äòz."
        )
        return WAITING_FOR_TEXT

    context.user_data["text"] = text

    update.message.reply_text(
        "‚è≥ <b>Matn tahlil qilinmoqda...</b>",
        parse_mode="HTML"
    )

    return analyze_text(update, context)


def analyze_text(update: Update, context: CallbackContext):
    text = context.user_data.get("text", "")

    try:
        response = openai.ChatCompletion.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": SYSTEM_PROMPT},
                {"role": "user", "content": text},
            ],
            max_tokens=400,
        )

        raw = response["choices"][0]["message"]["content"]

        try:
            data = json.loads(raw)
        except Exception:
            logger.exception("AI Detection JSON parse failed")
            data = {
                "ai_probability": "‚Äî",
                "confidence": "Low",
                "explanation": "Tahlil jarayonida texnik noaniqlik yuz berdi.",
                "ai_segments": "Aniqlanmadi."
            }

    except Exception:
        logger.exception("AI Detection failed")
        data = {
            "ai_probability": "‚Äî",
            "confidence": "Low",
            "explanation": "AI tahlilini bajarishda xatolik yuz berdi.",
            "ai_segments": "Aniqlanmadi."
        }

    output = _format_result(data)

    update.message.reply_text(
        output,
        parse_mode="HTML",
        reply_markup=_next_actions_keyboard()
    )

    return ConversationHandler.END


def cancel(update: Update, context: CallbackContext):
    user = update.effective_user
    if user:
        clear_checker_mode(user.id)

    context.user_data.clear()

    update.message.reply_text("‚ùå Bekor qilindi.")
    return ConversationHandler.END


# ---------- Registration ----------

def register(dispatcher):
    conv = ConversationHandler(
        per_message=False,
        entry_points=[
            CommandHandler("ai_detect", start_ai_detect),
        ],
        states={
            WAITING_FOR_TEXT: [
                MessageHandler(Filters.text & ~Filters.command, collect_text),
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        allow_reentry=False,
    )

    dispatcher.add_handler(conv, group=2)


def setup(dispatcher):
    register(dispatcher)
